# CASCADE Regeln - AI Assistant Memory

## üìö **WICHTIG: DWEapp.md ist die zentrale Wahrheitsquelle!**

**üîî ZUERST in `DWEapp.md` nachschauen:**
- **Architektur & Ordnerstruktur** ‚Üí Wo ist welche Datei?
- **Komponenten √úbersicht** ‚Üí Was gibt es bereits?
- **API Integration** ‚Üí Wie funktioniert WeClapp?
- **Version History** ‚Üí Was wurde wann ge√§ndert?

**üìã Alle Dokumentationen im √úberblick:**
- **`DWEapp.md`** ‚Üí Hauptdokumentation (Architektur, Komponenten, API)
- **`DATABASE.md`** ‚Üí Datenbankschema & Sync-Dokumentation
- **`CHANGELOG.md`** ‚Üí √Ñnderungsprotokoll mit Rollback-Anweisungen
- **`CASCADE.md`** ‚Üí Detaillierte Entwicklungsregeln
- **`.cascade-rules.md`** ‚Üí Diese Datei (AI Assistant Regeln)

**üìã DOKUMENTATIONS-REGELN:**
- **Immer `DWEapp.md` aktualisieren** bei √Ñnderungen
- **Neue Komponenten** dort dokumentieren
- **API √Ñnderungen** eintragen
- **Version History** pflegen

---

## üö® **IMMER VOR CODE SCHREIBEN PR√úFEN:**

### **1. Datei-Gr√∂√üen (nach Typ)**

| Dateityp | Ideal | Maximum | Warum |
|----------|-------|---------|-------|
| **React Component** | 80‚Äì150 | 250 | Eine UI-Aufgabe |
| **Custom Hook** | 40‚Äì120 | 200 | Eine Logik-Aufgabe |
| **API-Funktion** | 20‚Äì80 | 150 | Ein Endpoint |
| **Utility-Funktion** | 10‚Äì50 | 100 | Helper bleiben klein |
| **Type/Interface** | 5‚Äì50 | 100 | Nur Typen, keine Logik |
| **Test-Datei** | 50‚Äì200 | 400 | Tests k√∂nnen l√§nger sein |

**√úber Maximum ‚Üí aufteilen!**

### **2. CSS-Regeln**
- ‚ùå `bg-white`, `text-gray-900`, `border-red-500`
- ‚úÖ `bg-[var(--bg-primary)]`, `text-[var(--primary)]`, `border-[var(--error)]`

### **3. UI-Komponenten**
- ‚úÖ `import { Button } from '@/components/ui/button'`
- ‚úÖ `import { Plus, User, Package } from 'lucide-react'`
- ‚úÖ `import { useReactTable } from '@tanstack/react-table'`
- ‚úÖ **WIEDERVERWENDUNG**: Immer importieren, nicht neu bauen
- üé® **Design-System Demo**: `/design-system`
- üìã **DEMO-REGEL**: Alle neuen UI-Komponenten zur Demo hinzuf√ºgen!
- ‚ùå Direkte Library-Imports

### **4. Deutsche Texte**
- UI-Texte: Deutsch
- Code: Englisch

### **5. Minimal Changes**
- Nur was n√∂tig √§ndern
- Kein Over-Engineering

### **6. Dokumentations-Pflicht**
- **Immer `DWEapp.md` aktualisieren** bei √Ñnderungen
- **Neue Komponenten** ‚Üí Dateiliste eintragen
- **API √Ñnderungen** ‚Üí API-Sektion eintragen
- **Version Updates** ‚Üí Version History eintragen

### **7. Design-System Demo Pflicht**
- **Immer `/design-system` Demo anpassen** bei UI-Komponenten √Ñnderungen
- **Neue Komponenten** ‚Üí Zur Demo hinzuf√ºgen
- **Ge√§nderte Komponenten** ‚Üí Demo aktualisieren
- **Alle Varianten** zeigen (mit/ohne Text, verschiedene Props)

---

## üîÑ **Mein Workflow:**

1. **üìã Regeln pruefen** (`.cascade-rules.md`)
2. **üìö Doku lesen** (`DWEapp.md` - Architektur, Komponenten, API)
3. **ü§î Ueberlegen** (Planung, CASCADE-Check)
4. **‚ö° Ausfuehren** (Code schreiben, Tools nutzen)
5. **üîç TypeScript-Check** (`npx tsc --noEmit` - ALLE Fehler auf einmal finden)
6. **üé® Demo anpassen** (`/design-system` - UI-Komponenten zeigen)
7. **üìù Doku aktualisieren** (`DWEapp.md` - Aenderungen dokumentieren)

**üéØ Zuerst pruefen, dann denken, dann handeln, dann demonstrieren!**

---

## üîç **Debugging-Strategie (VOR Build!):**

**WICHTIG: Nie blind builden! Erst scannen, dann fixen!**

### Schritt 1: Alle Fehler scannen
```bash
npx tsc --noEmit
```

### Schritt 2: Fehler sammeln und gruppieren
- Alle Fehler notieren
- Nach Datei/Typ gruppieren
- Abhaengigkeiten erkennen

### Schritt 3: Alle Fehler auf einmal beheben
- Zusammenhaengende Fehler zusammen fixen
- Nicht nach jedem Fix neu builden
- Erst wenn ALLE behoben: Build starten

### Vorteile:
- Spart Zeit (kein wiederholtes Builden)
- Erkennt Zusammenhaenge zwischen Fehlern
- Verhindert Ping-Pong Fixes

---

## üöÄ **Server Deployment (CI/CD):**

**Siehe `DEVELOPMENT.md` fuer vollstaendige Anleitung!**

### Automatisches Deploy (CI/CD):
```bash
# Einfach pushen - GitHub Actions deployed automatisch!
git add .
git commit -m "Feature: ..."
git push
```

GitHub Actions:
1. ‚úÖ TypeScript Check
2. ‚úÖ Build Test  
3. ‚úÖ SSH auf Server
4. ‚úÖ Docker Build (--no-cache)
5. ‚úÖ Production Container neu starten

### Entwicklung mit Windsurf SSH:
```bash
# 1. Windsurf: Ctrl+Shift+P ‚Üí "Remote-SSH: Connect to Host"
# 2. Host: root@91.98.135.191
# 3. Ordner: /opt/weclapp-manager

# Dev-Container starten (Hot Reload auf Port 3001):
docker-compose --profile dev up -d DWEappDev
```

### Server-Infos:
- **IP:** 91.98.135.191
- **SSH-Key:** `dweapp-deploy` (lokal in c:\dev\DWEapp\)
- **GitHub Secret:** `SSH_PRIVATE_KEY` (gleicher Key-Inhalt)
- **Dev:** Port 3001 (Hot Reload)
- **Prod:** Port 3000 (via nginx SSL)

---

## üóÑÔ∏è **Datenbank-Regeln (KRITISCH!):**

**Siehe `DATABASE.md` fuer vollstaendige Anleitung!**

### PostgreSQL Spalten-Namen:
- ‚ùå `lastLoginAt` (wird zu `lastloginat`!)
- ‚úÖ `"lastLoginAt"` (bleibt camelCase!)

### Schema-Aenderungen:
```bash
# 1. Backup
docker exec weclapp-manager-db-1 pg_dump -U postgres dweapp > /tmp/backup.sql

# 2. Prisma sync (NICHT manuelles SQL!)
docker-compose exec -T production npx prisma db push --accept-data-loss

# 3. Neu deployen (via git push ‚Üí CI/CD)
git push
```

### PowerShell Problem:
- ‚ùå Komplexe SQL ueber SSH
- ‚úÖ SQL in Datei auf Server, dann ausfuehren
- ‚úÖ Besser: `prisma db push` verwenden!

---

## üìã **Checklist vor jedem Tool-Call:**

```
‚ñ° DWEapp.md gepr√ºft? (Architektur, Komponenten, API)
‚ñ° Dateigr√∂√üe passend? (Component: 250, Hook: 200, API: 150, Utility: 100)
‚ñ° CSS-Variablen genutzt?
‚ñ° Zentrale UI-Komponenten?
‚ñ° **WIEDERVERWENDUNG**: Bestehende Komponenten genutzt?
‚ñ° **DEMO-REGEL**: Komponente zur Design-System Demo hinzugef√ºgt?
‚ñ° **DEMO-ANPASSUNG**: /design-system aktualisiert?
‚ñ° Lucide Icons verwendet?
‚ñ° Deutsche UI-Texte?
‚ñ° Minimale √Ñnderung?
‚ñ° DWEapp.md aktualisiert? (√Ñnderungen dokumentiert)
```

---

*Bei Verst√∂√üen: STOPP ‚Üí Korrigieren ‚Üí Weitermachen*
